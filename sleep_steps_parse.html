<!DOCTYPE html>
<meta charset="utf-8">
<a target="_blank" style="outline:none;"><canvas width="960" height="960"></canvas></a>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>

let canvas = document.querySelector("canvas");

var width = canvas.width,
    height = canvas.height;
    radius = Math.min(width, height) / 4;

let ctx = canvas.getContext('2d');

// This is to try and fix blurry edges on HDPI screens
var PIXEL_RATIO = (function () {
    var ctx = document.querySelector("canvas").getContext("2d"),
        dpr = window.devicePixelRatio || 1,
        bsr = ctx.webkitBackingStorePixelRatio ||
              ctx.mozBackingStorePixelRatio ||
              ctx.msBackingStorePixelRatio ||
              ctx.oBackingStorePixelRatio ||
              ctx.backingStorePixelRatio || 1;

    return dpr / bsr;
})();


createHiDPICanvas = function(w, h, ratio) {
    if (!ratio) { ratio = PIXEL_RATIO; }
    var can = document.createElement("canvas");
    can.width = w * ratio;
    can.height = h * ratio;
    can.style.width = w + "px";
    can.style.height = h + "px";
    can.getContext("2d").setTransform(ratio, 0, 0, ratio, 0, 0);
    return can;
}

//Create canvas with the device resolution.
var myCanvas = createHiDPICanvas(500, 250);

//Declare variables
let activityTotal = {};
let timechunk;
let timeChunkArray = [];
let sleepChunkArray = [];
let deepChunkArray = [];
let dayChoice = "2017-05-09";
let sleepColors = ["#F1F1F1","white"]
let deepColors = ["#5F5F5F","white"]

//This function parses RescueTime data

function rescueTimeParse(activityData){

  //Using the dayChoice variable we filter out only the rows that pertain to that day
  const singleDayFiltered = activityData.filter(activity => (activity[Object.keys(activity)[1]].includes(dayChoice)));

  console.log(singleDayFiltered)

  //Here we fill in empty cells with zeroes
  let activityCount = singleDayFiltered.map(currentRow => {
    if (typeof(activityTotal[Object.values(currentRow)[2]]) != "number"){
      activityTotal[Object.values(currentRow)[2]] = 0
    };

    //this part builds and objects where each key is an activity and tallies up the values for each over the entire day
    activityTotal[Object.values(currentRow)[2]] = parseInt(activityTotal[Object.values(currentRow)[2]]) + parseInt(Object.values(currentRow)[0]);
  }, 0);

  console.log(activityTotal)
};

//this is a scale meant to convert milliseconds to radial degrees
var degreeScale = d3.scaleLinear()
  .domain([0,86400000])
  .range([0,360]);

//this scale uses the amount of deep sleep in that period to generate a color value
var sleepColorScale = d3.scaleLinear()
                              .domain([-900000,900000])
                              .range([0,255]);

  //here we're converting Google Fit timestamps into milliseconds
function timestampMilliConverter(entry){
    timechunk = entry[ 'Start time' ].slice(0,5);
    timechunk = (Number(timechunk.split(':')[0])*60+Number(timechunk.split(':')[1]))*1000;
    timeChunkArray.push(timechunk)
    return;
  };


//This function parses Google Fit data (sleep, deep sleep, step count)
function fitParse(data) {
  //here we're iterating over each row and converting the values to integers
  //where the value is non-existant we mark it zero
    data.forEach(function(row){
      if (row[ 'Sleep duration (ms)' ] > 0){
        row[ 'Sleep duration (ms)' ] = parseInt(row[ 'Sleep duration (ms)' ])
      } else row[ 'Sleep duration (ms)' ] = 0;
      if (row[ 'Deep sleeping duration (ms)' ] > 0){
        row[ 'Deep sleeping duration (ms)' ] = parseInt(row[ 'Deep sleeping duration (ms)' ])
      } else row[ 'Deep sleeping duration (ms)' ] = 0;
      if (row[ 'Step count' ] > 0){
        row[ 'Step count' ] = parseInt(row[ 'Step count' ])
      } else row[ 'Step count' ] = 0;
    });

    //here we use reduce functions to tally up the amount of each
      const lightCount = data.reduce((total, chunk) => {
        sleepChunkArray.push(chunk[ 'Sleep duration (ms)' ]);
        return total + chunk[ 'Sleep duration (ms)' ];
      }, 0);
      const deepCount = data.reduce((total, chunk) => {
        deepChunkArray.push(chunk[ 'Deep sleeping duration (ms)' ]);
        return total + chunk[ 'Deep sleeping duration (ms)' ];
      }, 0);
      const stepCount = data.reduce((total, chunk) => {
        return total + chunk[ 'Step count' ];
      }, 0);

      //adding up the total count
      const sleepCount = lightCount + deepCount;
      const sleepCountArray = [sleepCount, 86400000];


      let deepRadius =  ((deepCount/sleepCount)*radius);
      let rotateOffset = (sleepCount/86400000)
      let rotateOffsetFinal = (90 + ((rotateOffset/2)*360));

      const test = data.forEach((chunk) => {
        timestampMilliConverter(chunk)
      });


      //
      // var arc = d3.arc()
      //     .outerRadius(radius)
      //     .innerRadius(0)
      //     .context(ctx);
      //
      // var deepArc = d3.arc()
      //     .outerRadius(deepRadius)
      //     .innerRadius(0)
      //     .context(ctx);
      //
      //
      // var pie = d3.pie()
      //     .sort(null)
      //     .value(function(d) { return d; });
      //
      // ctx.translate(width / 2, height / 2);
      // ctx.rotate(rotateOffsetFinal * Math.PI / 180);
      //
      // var sleepArcs = pie(timeChunkArray);
      //
      // sleepArcs.forEach(function(d, i) {
      //   ctx.beginPath();
      //   arc(d);
      //   ctx.fillStyle = sleepColorScale(d);
      //   ctx.fill();
      // });

      // var deepArcs = pie(sleepCountArray);
      //
      // deepArcs.forEach(function(d, i) {
      //   ctx.beginPath();
      //   deepArc(d);
      //   ctx.fillStyle = deepColors[i];
      //   ctx.fill();
      // });
  };


  
  //     var arc = d3.arc()
  //         .outerRadius(radius)
  //         .innerRadius(0)
  //         .context(ctx);
  //
  //     var deepArc = d3.arc()
  //         .outerRadius(deepRadius)
  //         .innerRadius(0)
  //         .context(ctx);
  //
  //
  //     var pie = d3.pie()
  //         .sort(null)
  //         .value(function(d) { return d; });
  //
  //     ctx.translate(width / 2, height / 2);
  //     ctx.rotate(rotateOffsetFinal * Math.PI / 180);
  //
  //     var sleepArcs = pie(sleepCountArray);
  //
  //     sleepArcs.forEach(function(d, i) {
  //       ctx.beginPath();
  //       arc(d);
  //       ctx.fillStyle = sleepColors[i];
  //       ctx.fill();
  //     });
  //
  //     var deepArcs = pie(sleepCountArray);
  //
  //     deepArcs.forEach(function(d, i) {
  //       ctx.beginPath();
  //       deepArc(d);
  //       ctx.fillStyle = deepColors[i];
  //       ctx.fill();
  //     });
  // };

  d3.csv("test_data/" + dayChoice + ".csv", function(fitData){
      fitParse(fitData);
    });

  d3.csv("test_data/rescuetime-activity-history.csv", function(rescueTimeData){
      rescueTimeParse(rescueTimeData);
    });

</script>
