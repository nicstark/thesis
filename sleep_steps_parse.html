<!DOCTYPE html>
<meta charset="utf-8">
<a target="_blank" style="outline:none;"><canvas width="960" height="1960"></canvas></a>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>

let canvas = document.querySelector("canvas");

var width = canvas.width,
    height = canvas.height;
    radius = Math.min(width, height) / 4;

let ctx = canvas.getContext('2d');

// This is to try and fix blurry edges on HDPI screens
var PIXEL_RATIO = (function () {
    var ctx = document.querySelector("canvas").getContext("2d"),
        dpr = window.devicePixelRatio || 1,
        bsr = ctx.webkitBackingStorePixelRatio ||
              ctx.mozBackingStorePixelRatio ||
              ctx.msBackingStorePixelRatio ||
              ctx.oBackingStorePixelRatio ||
              ctx.backingStorePixelRatio || 1;

    return dpr / bsr;
})();


createHiDPICanvas = function(w, h, ratio) {
    if (!ratio) { ratio = PIXEL_RATIO; }
    var can = document.createElement("canvas");
    can.width = w * ratio;
    can.height = h * ratio;
    can.style.width = w + "px";
    can.style.height = h + "px";
    can.getContext("2d").setTransform(ratio, 0, 0, ratio, 0, 0);
    return can;
}

//Create canvas with the device resolution.
var myCanvas = createHiDPICanvas(500, 250);

//Declare variables
let activityTotal = {};
let activityArray = [];
let newArray = [];
let timechunk;
let result;
let max;
let citiDateFix;
let transactions;
let singleDayFiltered;
let xPos = 0 - width/2;
let transactionPos = 0 - width/2;
let timeChunkArray = [];
let sleepChunkArray = [];
let deepChunkArray = [];
let dayChoice = "2017-05-10";
let sleepColors = ["#F1F1F1","white"]
let deepColors = ["#5F5F5F","white"]


function citiParse(citiData){
  let citiDateFix = citiData.map(currentRow => {
    let oldDate = currentRow['Date'].split("/");
    let newDate = oldDate[2] + "-" + oldDate[0] + "-" + oldDate[1];
    currentRow['Date'] = newDate;
    return currentRow;

  })
  transactions = citiDateFix.filter(row => (row['Date'].includes(dayChoice)));
  console.log(transactions);

  let transactionMax = d3.max(transactions, function(d) { return +d['Debit']} );

  console.log(transactionMax);

  transationDraw(transactionMax);

}

//This function parses RescueTime data

function rescueTimeParse(activityData){

  //Using the dayChoice variable we filter out only the rows that pertain to that day
  singleDayFiltered = activityData.filter(activity => (activity[Object.keys(activity)[1]].includes(dayChoice)));


  //Here we fill in empty cells with zeroes
  let activityCount = singleDayFiltered.map(currentRow => {
    if (typeof(activityTotal[Object.values(currentRow)[2]]) != "number"){
      activityTotal[Object.values(currentRow)[2]] = 0
    };

    //this part builds and objects where each key is an activity and tallies up the values for each over the entire day
    activityTotal[Object.values(currentRow)[2]] = parseInt(activityTotal[Object.values(currentRow)[2]]) + parseInt(Object.values(currentRow)[0]);

    newArray.push({
      "name" : Object.values(currentRow)[2],
      "amount" : parseInt(activityTotal[Object.values(currentRow)[2]]) + parseInt(Object.values(currentRow)[0]),
      "category" : Object.values(currentRow)[4]
    })
  }, 0);

    activityArray = Object.entries(activityTotal);

    activityArray.sort(function(x, y){
   return d3.ascending(x[1], y[1]);
    })
    let max = d3.max(activityArray, function(d) { return +d[1]} );

    activityDraw(max)

};

function transationDraw(transactionMax){

    var transactionScalePos = d3.scaleLinear()
      .domain([0, transactionMax])
      .range([10, width - 10]);


    var transactionScale = d3.scaleLinear()
      .domain([0, transactionMax])
      .range([0, 100]);

    transactions.forEach(function(d, i) {
      ctx.beginPath();
      console.log(transactionScale(d['Debit']));
      ctx.rect(transactionPos, -1*transactionScale(d['Debit']/2), transactionScale(d['Debit']), transactionScale(d['Debit']));
      transactionPos = transactionPos + transactionScale(d['Debit'])+2;
      ctx.fillStyle="blue";
      ctx.fill();
      ctx.closePath();
    });
}


function activityDraw(max){

  var scalePos = d3.scaleLinear()
    .domain([0, max])
    .range([10, width - 10]);


  var scale = d3.scaleLinear()
    .domain([0, max])
    .range([0, 100]);


activityArray.forEach(function(d, i) {
  ctx.beginPath();
  ctx.rect(-1*scale(d[1]/2), xPos, scale(d[1]), scale(d[1]));
  xPos = xPos + scale(d[1])+2;
  ctx.fillStyle="grey";
  ctx.fill();
  ctx.closePath();
});
};

//this is a scale meant to convert milliseconds to radial degrees
var degreeScale = d3.scaleLinear()
  .domain([0,86400000])
  .range([0,360]);

//this scale uses the amount of deep sleep in that period to generate a color value
var sleepColorScale = d3.scaleLinear()
                              .domain([-900000,900000])
                              .range([0,255]);

  //here we're converting Google Fit timestamps into milliseconds
function timestampMilliConverter(entry){
    timechunk = entry[ 'Start time' ].slice(0,5);
    timechunk = (Number(timechunk.split(':')[0])*60+Number(timechunk.split(':')[1]))*1000;
    timeChunkArray.push(timechunk)
    return;
  };


//This function parses Google Fit data (sleep, deep sleep, step count)
function fitParse(data) {
  //here we're iterating over each row and converting the values to integers
  //where the value is non-existant we mark it zero
    data.forEach(function(row){
      if (row[ 'Sleep duration (ms)' ] > 0){
        row[ 'Sleep duration (ms)' ] = parseInt(row[ 'Sleep duration (ms)' ])
      } else row[ 'Sleep duration (ms)' ] = 0;
      if (row[ 'Deep sleeping duration (ms)' ] > 0){
        row[ 'Deep sleeping duration (ms)' ] = parseInt(row[ 'Deep sleeping duration (ms)' ])
      } else row[ 'Deep sleeping duration (ms)' ] = 0;
      if (row[ 'Step count' ] > 0){
        row[ 'Step count' ] = parseInt(row[ 'Step count' ])
      } else row[ 'Step count' ] = 0;
    });

    //here we use reduce functions to tally up the amount of each
      const lightCount = data.reduce((total, chunk) => {
        sleepChunkArray.push(chunk[ 'Sleep duration (ms)' ]);
        return total + chunk[ 'Sleep duration (ms)' ];
      }, 0);
      const deepCount = data.reduce((total, chunk) => {
        deepChunkArray.push(chunk[ 'Deep sleeping duration (ms)' ]);
        return total + chunk[ 'Deep sleeping duration (ms)' ];
      }, 0);
      const stepCount = data.reduce((total, chunk) => {
        return total + chunk[ 'Step count' ];
      }, 0);

      //adding up the total count
      const sleepCount = lightCount + deepCount;
      const sleepCountArray = [sleepCount, 86400000];


      let deepRadius =  ((deepCount/sleepCount)*radius);
      let rotateOffset = (sleepCount/86400000)
      let rotateOffsetFinal = (90 + ((rotateOffset/2)*360));

      const test = data.forEach((chunk) => {
        timestampMilliConverter(chunk)
      });

      // activityTotal.forEach(function(d, i) {
      //   context.beginPath();
      //   context.rect(scale(d), 150, 10, 10);
      //   context.fillStyle="red";
      //   context.fill();
      //   context.closePath();
      // });

      var arc = d3.arc()
          .outerRadius(radius)
          .innerRadius(0)
          .context(ctx);

      var deepArc = d3.arc()
          .outerRadius(deepRadius)
          .innerRadius(0)
          .context(ctx);


      var pie = d3.pie()
          .sort(null)
          .value(function(d) { return d; });

      ctx.translate(width / 2, height / 2);
    //  ctx.rotate(rotateOffsetFinal * Math.PI / 180);

      var sleepArcs = pie([50,50]);

      sleepArcs.forEach(function(d, i) {
        ctx.beginPath();
        arc(d);
        ctx.fillStyle = sleepColors[i];
        ctx.fill();
      });

      var deepArcs = pie([50,50]);

      deepArcs.forEach(function(d, i) {
        ctx.beginPath();
        deepArc(d);
        ctx.fillStyle = deepColors[i];
        ctx.fill();
      });
  };

  d3.csv("test_data/" + dayChoice + ".csv", function(fitData){
      fitParse(fitData);
    });

  d3.csv("test_data/rescuetime-activity-history.csv", function(rescueTimeData){
      rescueTimeParse(rescueTimeData);
    });

  d3.csv("test_data/Citi.csv", function(citiData){
      citiParse(citiData);
    });

</script>
